# SignaLink 3 SQL loader script


**Description:**

This script takes a SignaLinK 3 compatible SQLite DB file, and converts it to Sherlock compatible JSON format.
Most of the JSON attributes are taken from the DB file, but some of them are provided as input parameters.
The script automatically create an output .json file in the output folder. The name of the output .json file will be
the same as the input SLK3 database file.


**Parameters:**

-i, --input-db-file <path>                                  : path to an SLK3 .db file [mandatory]

-int_a_id, --interactor-a-molecule-type-mi-id <int>         : MI ID entity type of interactor A [mandatory]

-int_a_tn, --interactor-a-molecule-type-mi-term-name <str>  : MI term name entity type of interactor A [mandatory]

-int_b_id, --interactor-b-molecule-type-mi-id <int>         : MI ID entity type of interactor B [mandatory]

-int_b_tn, --interactor-b-molecule-type-mi-term-name <str>  : MI term name entity type of interactor B [mandatory]

-db, --source-database-mi-id <int>                          : single MI ID of the database [optional]

-o, --output-folder <path>                                  : path to an output folder [mandatory]


**Exit codes**

Exit code 1: The specified input SLK3 database file doesn't exists!
Exit code 2: The specified input SLK3 database file is not a .db file!
Exit code 3: The specified output folder doesn't exists!


**Input file format**

The input files are standard SQLite db files, generated by the SignaLink 3 data loader scripts.

The expected schema in the db file is the following:
```
sqlite> .schema
CREATE TABLE `node` (
	`id`	INTEGER PRIMARY KEY,
	`name`	TEXT NOT NULL,
	`alt_accession`	TEXT,
	`tax_id`	INTEGER NOT NULL,
	`pathways`	TEXT,
	`aliases` TEXT,
	`topology` TEXT
);
CREATE TABLE `edge` (
	`id`	INTEGER PRIMARY KEY,
	`interactor_a_node_id`	INTEGER NOT NULL,
	`interactor_b_node_id`	INTEGER NOT NULL,
	`interactor_a_node_name`	TEXT NOT NULL,
	`interactor_b_node_name`	TEXT NOT NULL,
	`interaction_detection_method`	TEXT,
	`first_author`	TEXT,
	`publication_ids`	TEXT NOT NULL,
	`interaction_types`	TEXT,
	`source_db`	TEXT NOT NULL,
	`interaction_identifiers`	TEXT,
	`confidence_scores`	TEXT,
	`layer` INTEGER NOT NULL,
	FOREIGN KEY(`interactor_a_node_id`) REFERENCES node ( `id` ) ON UPDATE NO ACTION ON DELETE CASCADE,
	FOREIGN KEY(`interactor_b_node_id`) REFERENCES node ( `id` ) ON UPDATE NO ACTION ON DELETE CASCADE
);
```


**Output file format**

In the Sherlock compatible output json we have single json records per line. Here is an example for one 
json record (where we put each attribute in separate line for readability, but in the real json this is a single
line, and the lines are separated by only a new-line character, and no comma).

```
{
   "interactor_a_id": "ensg11867234247",
   "interactor_b_id": "ensg98236453842",
   "interactor_a_id_type": "ensembl",
   "interactor_b_id_type": "ensembl",
   "interactor_a_tax_id": 9606,
   "interactor_b_tax_id": 9606,
   "interactor_a_molecule_type_mi_id": 250,
   "interactor_b_molecule_type_mi_id": 250,
   "interactor_a_molecule_type_name": gene,
   "interactor_b_molecule_type_name": gene,
   "interaction_detection_methods_mi_id": [401, 58],
   "interaction_types_mi_id": [208],
   "source_databases_mi_id": [469],
   "pmids": [14847410, 9368760]
}
```

This script using the following syntaxes, when creating the values for each attribute:
- `interactor_a_id`: lowercase trimmed string, mandatory 
- `interactor_b_id`: lowercase trimmed string, mandatory 
- `interactor_a_id_type`: UniProtKB DBref, mandatory  
- `interactor_b_id_type`: UniProtKB DBref, mandatory
- `interactor_a_tax_id`: NCBI TaxID int, mandatory
- `interactor_b_tax_id`: NCBI TaxID int, mandatory
- `interactor_a_molecule_type_mi_id`: mi_id int, mandatory
- `interactor_b_molecule_type_mi_id`: mi_id int, mandatory
- `interactor_a_molecule_type_name`: lowercase trimmed string (mi term name), mandatory
- `interactor_b_molecule_type_name`: lowercase trimmed string (mi term name), mandatory
- `interaction_detection_methods_mi_id`: [mi_id int, ...], optional, default: empty list
- `interaction_types_mi_id`: [mi_id int, ...], optional, default: empty list
- `source_databases_mi_id`: [mi_id int, ...], optional, default: empty list
- `pmids`: [ pmid int, ...], optional, default: empty list


The following SQL query will list all the necessary attributes for each edge in the input DB file:
```
SELECT a.name AS a_name,
       b.name AS b_name,
       a.tax_id AS a_taxid,
       b.tax_id AS b_taxid,
       interaction_detection_method,
       interaction_types,
       publication_ids
FROM edge
     LEFT JOIN node a ON edge.interactor_a_node_id = a.id
     LEFT JOIN node b ON edge.interactor_b_node_id = b.id;
```