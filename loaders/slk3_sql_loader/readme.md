# SignaLink 3 SQL loader script


## Description:

This script takes a SignaLinK 3 compatible SQLite DB file, and converts it to Sherlock compatible JSON format.
Most of the JSON attributes are taken from the DB file, but some of them are provided as input parameters.

## Parameters:

- `--input-db <path to SQLite db file>` [mandatory]
- `--output-json <path to an output json file>` [mandatory]
- `--interactor-a-molecula-type-mi-id <integer>` [mandatory]
- `--interactor-a-molecula-type-mi-term-name <string term name>` [mandatory]
- `--interactor-b-molecula-type-mi-id <integer>` [mandatory]
- `--interactor-b-molecula-type-mi-term-name <string term name>` [mandatory]
- `--source-database-mi-id <integer>` [optional]


## Input file format

The input files are standard SQLite db files, generated by the SignaLink 3 data loader scripts.

The expected schema in the db file is the following:
```
sqlite> .schema
CREATE TABLE `node` (
	`id`	INTEGER PRIMARY KEY,
	`name`	TEXT NOT NULL,
	`alt_accession`	TEXT,
	`tax_id`	INTEGER NOT NULL,
	`pathways`	TEXT,
	`aliases` TEXT,
	`topology` TEXT
);
CREATE TABLE `edge` (
	`id`	INTEGER PRIMARY KEY,
	`interactor_a_node_id`	INTEGER NOT NULL,
	`interactor_b_node_id`	INTEGER NOT NULL,
	`interactor_a_node_name`	TEXT NOT NULL,
	`interactor_b_node_name`	TEXT NOT NULL,
	`interaction_detection_method`	TEXT,
	`first_author`	TEXT,
	`publication_ids`	TEXT NOT NULL,
	`interaction_types`	TEXT,
	`source_db`	TEXT NOT NULL,
	`interaction_identifiers`	TEXT,
	`confidence_scores`	TEXT,
	`layer` INTEGER NOT NULL,
	FOREIGN KEY(`interactor_a_node_id`) REFERENCES node ( `id` ) ON UPDATE NO ACTION ON DELETE CASCADE,
	FOREIGN KEY(`interactor_b_node_id`) REFERENCES node ( `id` ) ON UPDATE NO ACTION ON DELETE CASCADE
);
```

## Output file format

In the Sherlock compatible output json we have single json records per line. Here is an example for one 
json record (where we put each attribute in separate line for readability, but in the real json this is a single
line, and the lines are separated by only a new-line character, and no comma).

```
{
   "interactor_a_id": "ensg11867234247",
   "interactor_b_id": "ensg98236453842",
   "interactor_a_id_type": "Ensembl",
   "interactor_b_id_type": "Ensembl",
   "interactor_a_tax_id": 9606,
   "interactor_b_tax_id": 9606,
   "interactor_a_molecula_type_mi_id": 250,
   "interactor_b_molecula_type_mi_id": 250,
   "interactor_a_molecula_type_name": gene,
   "interactor_b_molecula_type_name": gene,
   "interaction_detection_methods_mi_id": [401, 58],
   "interaction_types_mi_id": [208],
   "source_databases_mi_id": [469],
   "pmids": [14847410, 9368760]
}
```

Use the following syntax when crating the values for each attribute:
- `interactor_a_id`: lowercase trimmed string, mandatory 
- `interactor_b_id`: lowercase trimmed string, mandatory 
- `interactor_a_id_type`: UniProtKB DBref, mandatory  
- `interactor_b_id_type`: UniProtKB DBref, mandatory
- `interactor_a_tax_id`: NCBI TaxID int, mandatory
- `interactor_b_tax_id`: NCBI TaxID int, mandatory
- `interactor_a_molecula_type_mi_id`: mi_id int, mandatory
- `interactor_b_molecula_type_mi_id`: mi_id int, mandatory
- `interactor_a_molecula_type_name`: lowercase trimmed string (mi term name), mandatory
- `interactor_b_molecula_type_name`: lowercase trimmed string (mi term name), mandatory
- `interaction_detection_methods_mi_id`: [mi_id int, ...], optional, default: empty list
- `interaction_types_mi_id`: [mi_id int, ...], optional, default: empty list
- `source_databases_mi_id`: [mi_id int, ...], optional, default: empty list
- `pmids`: [ pmid int, ...], optional, default: empty list




## Mapping between SQLite columns and JSON attributes

- `interactor_a_id`: second part of `node.name` 
- `interactor_b_id`: second part of `node.name` 
- `interactor_a_id_type`: first part of `node.name`
- `interactor_b_id_type`: first part of `node.name`
- `interactor_a_tax_id`: see `node.taxid`
- `interactor_b_tax_id`: see `node.taxid`
- `interactor_a_molecula_type_mi_id`: provided as input parameter
- `interactor_b_molecula_type_mi_id`: provided as input parameter
- `interactor_a_molecula_type_name`: provided as input parameter
- `interactor_b_molecula_type_name`: provided as input parameter
- `interaction_detection_methods_mi_id`: [mi_id int, ...], all MI IDs from `edge.interaction_detection_method`
- `interaction_types_mi_id`: [mi_id int, ...], all MI IDs from `edge.interaction_types`
- `source_databases_mi_id`: [mi_id int, ...], single MI ID provided as input parameter (optional)
- `pmids`: [ pmid int, ...], all pubmed IDs from `edge.publication_ids`



The following SQL query will list all the necessary attributes for each edge in the input DB file:

```
SELECT a.name AS a_name,
       b.name AS b_name,
       a.tax_id AS a_taxid,
       b.tax_id AS b_taxid,
       interaction_detection_method,
       interaction_types,
       publication_ids
FROM edge
     LEFT JOIN node a ON edge.interactor_a_node_id = a.id
     LEFT JOIN node b ON edge.interactor_b_node_id = b.id;
```